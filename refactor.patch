diff --git a/Makefile b/Makefile
index 01a3231..4f28fe8 100644
--- a/Makefile
+++ b/Makefile
@@ -26,5 +26,6 @@ lint:
 generate: generate-sqlc-code
 
 .PHONY: generate-sqlc-code
-generate-sqlc-code:	
+generate-sqlc-code:
+	@ rm -rf pkg/gendb
 	@ sqlc generate --file=sqlc.yaml
\ No newline at end of file
diff --git a/cmd/add-drop-classes-api/main.go b/cmd/add-drop-classes-api/main.go
index dba2de5..14b8df7 100644
--- a/cmd/add-drop-classes-api/main.go
+++ b/cmd/add-drop-classes-api/main.go
@@ -1,23 +1,20 @@
 package main
 
 import (
+	"github.com/TulgaCG/add-drop-classes-api/pkg/app"
 	"log"
-
-	"github.com/TulgaCG/add-drop-classes-api/pkg/database"
-	"github.com/TulgaCG/add-drop-classes-api/pkg/server"
+	"log/slog"
+	"os"
 )
 
 const dbPath = "test.sqlite"
 
 func main() {
-	db, err := database.New(dbPath)
-	if err != nil {
-		log.Fatalf("failed to create db connection: %s", err.Error())
-	}
-
-	s := server.New(db)
-	err = s.Run()
-	if err != nil {
-		log.Fatalf("failed to run server instance: %s", err.Error())
+	slogger := slog.New(slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{}))
+	if err := app.Run(&app.Conf{
+		DbPath: dbPath,
+		Log:    slogger,
+	}); err != nil {
+		log.Fatal("failed to run application: %w", err)
 	}
 }
diff --git a/database/queries/auth_queries.sql b/database/queries/auth_queries.sql
deleted file mode 100644
index e875441..0000000
--- a/database/queries/auth_queries.sql
+++ /dev/null
@@ -1,12 +0,0 @@
--- name: UpdateToken :one
-UPDATE users
-set token = ?,
-token_expire_at = CURRENT_TIMESTAMP
-WHERE id = ?
-RETURNING token;
-
--- name: UpdateExpirationToken :one
-UPDATE users
-set token_expire_at = ?
-WHERE id = ?
-RETURNING *;
\ No newline at end of file
diff --git a/database/queries/role_queries.sql b/database/queries/role_queries.sql
deleted file mode 100644
index 7fc209c..0000000
--- a/database/queries/role_queries.sql
+++ /dev/null
@@ -1,14 +0,0 @@
--- name: GetRoleName :one
-SELECT role FROM roles
-WHERE id = ?;
-
--- name: CreateRole :one
-INSERT INTO roles(role)
-VALUES (?)
-RETURNING role;
-
--- name: DeleteRoleByName :exec
-DELETE FROM roles WHERE role = ?;
-
--- name: DeleteRoleByID :exec
-DELETE FROM roles WHERE id = ?;
\ No newline at end of file
diff --git a/database/queries/user_queries.sql b/database/queries/user_queries.sql
index a3347b9..7343569 100644
--- a/database/queries/user_queries.sql
+++ b/database/queries/user_queries.sql
@@ -1,13 +1,17 @@
 -- name: GetUser :one
-SELECT * FROM users
+SELECT id, username FROM users
 WHERE id = ? LIMIT 1;
 
 -- name: GetUserByUsername :one
+SELECT id, username FROM users
+WHERE username = ? LIMIT 1;
+
+-- name: GetUserCredentialsWithUsername :one
 SELECT * FROM users
 WHERE username = ? LIMIT 1;
 
 -- name: ListUsers :many
-SELECT * FROM users
+SELECT id, username FROM users
 ORDER BY username;
 
 -- name: CreateUser :one
@@ -16,15 +20,23 @@ INSERT INTO users (
 ) VALUES (
     ?, ?
 )
-RETURNING *;
-
--- name: DeleteUser :execrows
-DELETE FROM users
-WHERE id = ?;
+RETURNING id, username;
 
 -- name: UpdateUser :one
 UPDATE users
 set username = ?,
 password = ?
 WHERE id = ?
-RETURNING *;
\ No newline at end of file
+RETURNING id, username;
+
+-- name: UpdateToken :one
+UPDATE users
+set token = ?,
+    token_expire_at = ?
+WHERE id = ?
+RETURNING username, token;
+
+-- name: UpdateTokenExpirationDate :exec
+UPDATE users
+set token_expire_at = ?
+WHERE id = ?;
diff --git a/database/queries/user_role_queries.sql b/database/queries/user_role_queries.sql
deleted file mode 100644
index d1384eb..0000000
--- a/database/queries/user_role_queries.sql
+++ /dev/null
@@ -1,21 +0,0 @@
--- name: GetUserRole :many
-SELECT r.role
-FROM users u
-JOIN user_roles ur ON u.id = ur.user_id
-JOIN roles r ON ur.role_id = r.id
-WHERE u.id = ?;
-
--- name: CreateUserRole :exec
-INSERT INTO user_roles (user_id, role_id)
-SELECT ?, roles.id
-FROM roles
-WHERE roles.role = ?;
-
--- name: DeleteUserRole :exec
-DELETE FROM user_roles
-WHERE user_id = ?
-AND role_id = (
-    SELECT id
-    FROM roles
-    WHERE role = ?
-);
\ No newline at end of file
diff --git a/database/schema.sql b/database/schema.sql
index 0f25128..73946e5 100644
--- a/database/schema.sql
+++ b/database/schema.sql
@@ -5,21 +5,3 @@ CREATE TABLE IF NOT EXISTS users (
     token VARCHAR(64),
     token_expire_at DATETIME
 );
-
-CREATE TABLE IF NOT EXISTS user_roles(
-    id INTEGER PRIMARY KEY,
-    user_id INTEGER NOT NULL,
-    role_id VARCHAR(255) NOT NULL,
-    UNIQUE(user_id,role_id),
-    FOREIGN KEY (user_id) REFERENCES users(id)
-        ON DELETE CASCADE
-        ON UPDATE CASCADE,
-    FOREIGN KEY (role_id) REFERENCES roles(id)
-        ON DELETE CASCADE
-        ON UPDATE CASCADE
-);
-
-CREATE TABLE IF NOT EXISTS roles(
-    id INTEGER PRIMARY KEY,
-    role VARCHAR(255) NOT NULL UNIQUE
-);
\ No newline at end of file
diff --git a/go.mod b/go.mod
index f1cc288..e18a769 100644
--- a/go.mod
+++ b/go.mod
@@ -5,6 +5,7 @@ go 1.21
 require (
 	github.com/gin-gonic/gin v1.9.1
 	github.com/mattn/go-sqlite3 v1.14.17
+	golang.org/x/crypto v0.12.0
 )
 
 require (
@@ -27,7 +28,6 @@ require (
 	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
 	github.com/ugorji/go/codec v1.2.11 // indirect
 	golang.org/x/arch v0.4.0 // indirect
-	golang.org/x/crypto v0.12.0 // indirect
 	golang.org/x/net v0.14.0 // indirect
 	golang.org/x/sys v0.11.0 // indirect
 	golang.org/x/text v0.12.0 // indirect
diff --git a/pkg/app/app.go b/pkg/app/app.go
new file mode 100644
index 0000000..d34e83d
--- /dev/null
+++ b/pkg/app/app.go
@@ -0,0 +1,29 @@
+package app
+
+import (
+	"context"
+	"fmt"
+	"log/slog"
+
+	"github.com/TulgaCG/add-drop-classes-api/pkg/database"
+	"github.com/TulgaCG/add-drop-classes-api/pkg/server"
+)
+
+type Conf struct {
+	DbPath string
+	Log    *slog.Logger
+}
+
+func Run(conf *Conf) error {
+	db, err := database.New(context.Background(), conf.DbPath)
+	if err != nil {
+		return fmt.Errorf("failed to create db connection: %w", err)
+	}
+
+	s := server.New(db, conf.Log)
+	if err = s.Run(); err != nil {
+		return fmt.Errorf("failed to run server instance: %w", err)
+	}
+
+	return nil
+}
diff --git a/pkg/auth/auth.go b/pkg/auth/auth.go
index 9e6c132..e4be0ca 100644
--- a/pkg/auth/auth.go
+++ b/pkg/auth/auth.go
@@ -6,155 +6,84 @@ import (
 	"database/sql"
 	"encoding/hex"
 	"fmt"
-	"net/http"
 	"time"
 
-	"github.com/gin-gonic/gin"
+	"golang.org/x/crypto/bcrypt"
 
-	"github.com/TulgaCG/add-drop-classes-api/pkg/common"
 	"github.com/TulgaCG/add-drop-classes-api/pkg/gendb"
-	"github.com/TulgaCG/add-drop-classes-api/pkg/types"
 )
 
-type UserParams struct {
-	TokenExpireAt time.Time      `json:"tokenExpireAt"`
-	Username      string         `json:"username"`
-	Password      string         `json:"password"`
-	Token         sql.NullString `json:"token"`
-	ID            types.UserID   `json:"id"`
-}
-
-type LoginResponse struct {
-	Username string `json:"username"`
-	Token    string `json:"token"`
-}
+const (
+	tokenLen      = 64
+	tokenDuration = 1 * time.Hour
+)
 
-func Login(c *gin.Context) {
-	var userToGet UserParams
-	if err := c.Bind(&userToGet); err != nil {
-		c.JSON(http.StatusBadRequest, common.Response{
-			Error: "bad request",
-		})
+func login(ctx context.Context, db *gendb.Queries, username, password string) (gendb.UpdateTokenRow, error) {
+	u, err := getUserCredentialsWithUsername(ctx, db, username)
+	if err != nil {
+		return gendb.UpdateTokenRow{}, fmt.Errorf("failed to get user with username including credentials: %w", err)
 	}
 
-	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
-	if !ok {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to get db",
-		})
-		return
+	if err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password)); err != nil {
+		return gendb.UpdateTokenRow{}, fmt.Errorf("invalid username or password")
 	}
 
-	user, err := db.GetUserByUsername(context.Background(), userToGet.Username)
+	token, err := createRandomToken()
 	if err != nil {
-		c.JSON(http.StatusBadRequest, common.Response{
-			Error: "failed to get user by username",
-		})
-		return
+		return gendb.UpdateTokenRow{}, fmt.Errorf("failed to create token: %w", err)
 	}
 
-	if user.Password != userToGet.Password {
-		c.JSON(http.StatusNotAcceptable, common.Response{
-			Error: "wrong password",
-		})
-		return
+	row, err := db.UpdateToken(ctx, gendb.UpdateTokenParams{
+		ID: u.ID,
+		Token: sql.NullString{
+			String: token,
+			Valid:  true,
+		},
+		TokenExpireAt: sql.NullTime{
+			Time:  time.Now().Add(tokenDuration),
+			Valid: true,
+		},
+	})
+	if err != nil {
+		return gendb.UpdateTokenRow{}, fmt.Errorf("failed to update token: %w", err)
 	}
 
-	if time.Since(user.TokenExpireAt.Time) > 0 {
-		generatedToken, err := createRandomToken()
-		if err != nil {
-			c.JSON(http.StatusInternalServerError, common.Response{
-				Error: "failed to generate token",
-			})
-		}
-
-		token, err := db.UpdateToken(context.Background(), gendb.UpdateTokenParams{
-			ID:    user.ID,
-			Token: sql.NullString{String: generatedToken, Valid: true},
-		})
-		if err != nil {
-			c.JSON(http.StatusInternalServerError, common.Response{
-				Error: "failed to update token",
-			})
-			return
-		}
-
-		_, err = db.UpdateExpirationToken(context.Background(), gendb.UpdateExpirationTokenParams{
-			ID:            user.ID,
-			TokenExpireAt: sql.NullTime{Time: time.Now().Add(common.ValidTime), Valid: true},
-		})
-		if err != nil {
-			c.JSON(http.StatusInternalServerError, common.Response{
-				Error: "failed to update token expiration date",
-			})
-			return
-		}
-
-		c.JSON(http.StatusOK, common.Response{
-			Data: LoginResponse{
-				Username: user.Username,
-				Token:    token.String,
-			},
-		})
-	} else {
-		c.JSON(http.StatusOK, common.Response{
-			Data: LoginResponse{
-				Username: user.Username,
-				Token:    user.Token.String,
-			},
-		})
-	}
+	return row, nil
 }
 
-func Logout(c *gin.Context) {
-	username := c.Request.Header.Get(common.UsernameHeaderKey)
-	token := c.Request.Header.Get(common.TokenHeaderKey)
-
-	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
-	if !ok {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to get db",
-		})
-		return
-	}
-
-	user, err := db.GetUserByUsername(context.Background(), username)
+func logout(ctx context.Context, db *gendb.Queries, username string) error {
+	user, err := db.GetUserCredentialsWithUsername(ctx, username)
 	if err != nil {
-		c.JSON(http.StatusNotAcceptable, common.Response{
-			Error: "username or database not found",
-		})
-		return
-	}
-
-	if user.Token.String != token {
-		c.JSON(http.StatusNotAcceptable, common.Response{
-			Error: "not logged in",
-		})
-		return
+		return fmt.Errorf("failed to get user by username: %w", err)
 	}
 
-	_, err = db.UpdateExpirationToken(context.Background(), gendb.UpdateExpirationTokenParams{
+	if err := db.UpdateTokenExpirationDate(ctx, gendb.UpdateTokenExpirationDateParams{
 		TokenExpireAt: sql.NullTime{
 			Time:  time.Now(),
 			Valid: false,
 		},
 		ID: user.ID,
-	})
+	}); err != nil {
+		return fmt.Errorf("failed to update token expiration date: %w", err)
+	}
+
+	return nil
+}
+
+func getUserCredentialsWithUsername(ctx context.Context, db *gendb.Queries, username string) (gendb.User, error) {
+	row, err := db.GetUserCredentialsWithUsername(ctx, username)
 	if err != nil {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to update token expiration date",
-		})
+		return gendb.User{}, fmt.Errorf("failed to get user: %w", err)
 	}
 
-	c.JSON(http.StatusOK, common.Response{
-		Data: username,
-	})
+	return row, nil
 }
 
 func createRandomToken() (string, error) {
-	b := make([]byte, common.TokenLength)
+	b := make([]byte, tokenLen)
 	if _, err := rand.Read(b); err != nil {
 		return "", fmt.Errorf("failed to create token: %w", err)
 	}
+
 	return hex.EncodeToString(b), nil
 }
diff --git a/pkg/auth/handler.go b/pkg/auth/handler.go
new file mode 100644
index 0000000..34c4a48
--- /dev/null
+++ b/pkg/auth/handler.go
@@ -0,0 +1,74 @@
+package auth
+
+import (
+	"log/slog"
+	"net/http"
+
+	"github.com/gin-gonic/gin"
+
+	"github.com/TulgaCG/add-drop-classes-api/pkg/common"
+	"github.com/TulgaCG/add-drop-classes-api/pkg/gendb"
+	"github.com/TulgaCG/add-drop-classes-api/pkg/server/response"
+)
+
+func LoginHandler(c *gin.Context) {
+	log, ok := c.MustGet(common.LogCtxKey).(*slog.Logger)
+	if !ok {
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindLoggerInCtx))
+		return
+	}
+
+	var req LoginRequest
+	err := c.BindJSON(&req)
+	if err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusBadRequest, response.WithError(response.ErrInvalidRequestFormat))
+		return
+	}
+
+	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
+	if !ok {
+		log.Error(err.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindDBInCtx))
+		return
+	}
+
+	row, err := login(c, db, req.Username, req.Password)
+	if err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusUnauthorized, response.WithError(response.ErrFailedToAuthenticate))
+		return
+	}
+
+	c.JSON(http.StatusOK, response.WithData(row))
+}
+
+func LogoutHandler(c *gin.Context) {
+	log, ok := c.MustGet(common.LogCtxKey).(*slog.Logger)
+	if !ok {
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindLoggerInCtx))
+		return
+	}
+
+	username := c.Request.Header.Get(common.UsernameHeaderKey)
+	if username == "" {
+		log.Error(response.ErrFailedToAuthenticate.Error())
+		c.JSON(http.StatusUnauthorized, response.WithError(response.ErrFailedToAuthenticate))
+		return
+	}
+
+	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
+	if !ok {
+		log.Error(response.ErrFailedToFindDBInCtx.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindDBInCtx))
+		return
+	}
+
+	if err := logout(c, db, username); err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusUnauthorized, response.WithError(response.ErrFailedToFindDBInCtx))
+		return
+	}
+
+	c.JSON(http.StatusOK, response.WithData(nil))
+}
diff --git a/pkg/auth/request.go b/pkg/auth/request.go
new file mode 100644
index 0000000..6d41df4
--- /dev/null
+++ b/pkg/auth/request.go
@@ -0,0 +1,8 @@
+package auth
+
+// TODO: Add playground-go/validator tags
+
+type LoginRequest struct {
+	Username string `json:"username"`
+	Password string `json:"password"`
+}
diff --git a/pkg/common/common.go b/pkg/common/common.go
index 441144c..041bd0b 100644
--- a/pkg/common/common.go
+++ b/pkg/common/common.go
@@ -1,16 +1,7 @@
 package common
 
-import "time"
-
 const (
-	ValidTime         = 1 * time.Hour
-	TokenLength       = 64
 	DatabaseCtxKey    = "db"
+	LogCtxKey         = "log"
 	UsernameHeaderKey = "Username"
-	TokenHeaderKey    = "Token"
 )
-
-type Response struct {
-	Data  any    `json:"data"`
-	Error string `json:"error"`
-}
diff --git a/pkg/database/database.go b/pkg/database/database.go
index 3492016..fcf3e62 100644
--- a/pkg/database/database.go
+++ b/pkg/database/database.go
@@ -12,14 +12,14 @@ import (
 	"github.com/TulgaCG/add-drop-classes-api/pkg/gendb"
 )
 
-func New(path string) (*gendb.Queries, error) {
+func New(ctx context.Context, path string) (*gendb.Queries, error) {
 	d, err := sql.Open("sqlite3", path)
 	if err != nil {
 		return nil, fmt.Errorf("failed to create db: %w", err)
 	}
 
 	// Create tables if not exist
-	if _, err := d.ExecContext(context.Background(), database.Schema); err != nil {
+	if _, err := d.ExecContext(ctx, database.Schema); err != nil {
 		return nil, fmt.Errorf("failed to create tables1: %w", err)
 	}
 
diff --git a/pkg/gendb/auth_queries.sql.go b/pkg/gendb/auth_queries.sql.go
deleted file mode 100644
index 6b5d232..0000000
--- a/pkg/gendb/auth_queries.sql.go
+++ /dev/null
@@ -1,58 +0,0 @@
-// Code generated by sqlc. DO NOT EDIT.
-// versions:
-//   sqlc v1.19.1
-// source: auth_queries.sql
-
-package gendb
-
-import (
-	"context"
-	"database/sql"
-
-	"github.com/TulgaCG/add-drop-classes-api/pkg/types"
-)
-
-const updateExpirationToken = `-- name: UpdateExpirationToken :one
-UPDATE users
-set token_expire_at = ?
-WHERE id = ?
-RETURNING id, username, password, token, token_expire_at
-`
-
-type UpdateExpirationTokenParams struct {
-	TokenExpireAt sql.NullTime `db:"token_expire_at" json:"tokenExpireAt"`
-	ID            types.UserID `db:"id" json:"id"`
-}
-
-func (q *Queries) UpdateExpirationToken(ctx context.Context, arg UpdateExpirationTokenParams) (User, error) {
-	row := q.db.QueryRowContext(ctx, updateExpirationToken, arg.TokenExpireAt, arg.ID)
-	var i User
-	err := row.Scan(
-		&i.ID,
-		&i.Username,
-		&i.Password,
-		&i.Token,
-		&i.TokenExpireAt,
-	)
-	return i, err
-}
-
-const updateToken = `-- name: UpdateToken :one
-UPDATE users
-set token = ?,
-token_expire_at = CURRENT_TIMESTAMP
-WHERE id = ?
-RETURNING token
-`
-
-type UpdateTokenParams struct {
-	Token sql.NullString `db:"token" json:"token"`
-	ID    types.UserID   `db:"id" json:"id"`
-}
-
-func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) (sql.NullString, error) {
-	row := q.db.QueryRowContext(ctx, updateToken, arg.Token, arg.ID)
-	var token sql.NullString
-	err := row.Scan(&token)
-	return token, err
-}
diff --git a/pkg/gendb/db.go b/pkg/gendb/db.go
index e910836..f78cb0a 100644
--- a/pkg/gendb/db.go
+++ b/pkg/gendb/db.go
@@ -1,6 +1,6 @@
 // Code generated by sqlc. DO NOT EDIT.
 // versions:
-//   sqlc v1.19.1
+//   sqlc v1.20.0
 
 package gendb
 
diff --git a/pkg/gendb/models.go b/pkg/gendb/models.go
index ab72193..8f217b3 100644
--- a/pkg/gendb/models.go
+++ b/pkg/gendb/models.go
@@ -1,6 +1,6 @@
 // Code generated by sqlc. DO NOT EDIT.
 // versions:
-//   sqlc v1.19.1
+//   sqlc v1.20.0
 
 package gendb
 
@@ -10,11 +10,6 @@ import (
 	"github.com/TulgaCG/add-drop-classes-api/pkg/types"
 )
 
-type Role struct {
-	ID   int64  `db:"id" json:"id"`
-	Role string `db:"role" json:"role"`
-}
-
 type User struct {
 	ID            types.UserID   `db:"id" json:"id"`
 	Username      string         `db:"username" json:"username"`
@@ -22,9 +17,3 @@ type User struct {
 	Token         sql.NullString `db:"token" json:"token"`
 	TokenExpireAt sql.NullTime   `db:"token_expire_at" json:"tokenExpireAt"`
 }
-
-type UserRole struct {
-	ID     int64  `db:"id" json:"id"`
-	UserID int64  `db:"user_id" json:"userId"`
-	RoleID string `db:"role_id" json:"roleId"`
-}
diff --git a/pkg/gendb/querier.go b/pkg/gendb/querier.go
index 3ddece8..04594bc 100644
--- a/pkg/gendb/querier.go
+++ b/pkg/gendb/querier.go
@@ -1,32 +1,24 @@
 // Code generated by sqlc. DO NOT EDIT.
 // versions:
-//   sqlc v1.19.1
+//   sqlc v1.20.0
 
 package gendb
 
 import (
 	"context"
-	"database/sql"
 
 	"github.com/TulgaCG/add-drop-classes-api/pkg/types"
 )
 
 type Querier interface {
-	CreateRole(ctx context.Context, role string) (string, error)
-	CreateUser(ctx context.Context, arg CreateUserParams) (User, error)
-	CreateUserRole(ctx context.Context, arg CreateUserRoleParams) error
-	DeleteRoleByID(ctx context.Context, id int64) error
-	DeleteRoleByName(ctx context.Context, role string) error
-	DeleteUser(ctx context.Context, id types.UserID) (int64, error)
-	DeleteUserRole(ctx context.Context, arg DeleteUserRoleParams) error
-	GetRoleName(ctx context.Context, id int64) (string, error)
-	GetUser(ctx context.Context, id types.UserID) (User, error)
-	GetUserByUsername(ctx context.Context, username string) (User, error)
-	GetUserRole(ctx context.Context, id types.UserID) ([]string, error)
-	ListUsers(ctx context.Context) ([]User, error)
-	UpdateExpirationToken(ctx context.Context, arg UpdateExpirationTokenParams) (User, error)
-	UpdateToken(ctx context.Context, arg UpdateTokenParams) (sql.NullString, error)
-	UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error)
+	CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error)
+	GetUser(ctx context.Context, id types.UserID) (GetUserRow, error)
+	GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error)
+	GetUserCredentialsWithUsername(ctx context.Context, username string) (User, error)
+	ListUsers(ctx context.Context) ([]ListUsersRow, error)
+	UpdateToken(ctx context.Context, arg UpdateTokenParams) (UpdateTokenRow, error)
+	UpdateTokenExpirationDate(ctx context.Context, arg UpdateTokenExpirationDateParams) error
+	UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error)
 }
 
 var _ Querier = (*Queries)(nil)
diff --git a/pkg/gendb/role_queries.sql.go b/pkg/gendb/role_queries.sql.go
deleted file mode 100644
index f767c85..0000000
--- a/pkg/gendb/role_queries.sql.go
+++ /dev/null
@@ -1,52 +0,0 @@
-// Code generated by sqlc. DO NOT EDIT.
-// versions:
-//   sqlc v1.19.1
-// source: role_queries.sql
-
-package gendb
-
-import (
-	"context"
-)
-
-const createRole = `-- name: CreateRole :one
-INSERT INTO roles(role)
-VALUES (?)
-RETURNING role
-`
-
-func (q *Queries) CreateRole(ctx context.Context, role string) (string, error) {
-	row := q.db.QueryRowContext(ctx, createRole, role)
-	err := row.Scan(&role)
-	return role, err
-}
-
-const deleteRoleByID = `-- name: DeleteRoleByID :exec
-DELETE FROM roles WHERE id = ?
-`
-
-func (q *Queries) DeleteRoleByID(ctx context.Context, id int64) error {
-	_, err := q.db.ExecContext(ctx, deleteRoleByID, id)
-	return err
-}
-
-const deleteRoleByName = `-- name: DeleteRoleByName :exec
-DELETE FROM roles WHERE role = ?
-`
-
-func (q *Queries) DeleteRoleByName(ctx context.Context, role string) error {
-	_, err := q.db.ExecContext(ctx, deleteRoleByName, role)
-	return err
-}
-
-const getRoleName = `-- name: GetRoleName :one
-SELECT role FROM roles
-WHERE id = ?
-`
-
-func (q *Queries) GetRoleName(ctx context.Context, id int64) (string, error) {
-	row := q.db.QueryRowContext(ctx, getRoleName, id)
-	var role string
-	err := row.Scan(&role)
-	return role, err
-}
diff --git a/pkg/gendb/user_queries.sql.go b/pkg/gendb/user_queries.sql.go
index 607fc3f..833bc15 100644
--- a/pkg/gendb/user_queries.sql.go
+++ b/pkg/gendb/user_queries.sql.go
@@ -1,12 +1,13 @@
 // Code generated by sqlc. DO NOT EDIT.
 // versions:
-//   sqlc v1.19.1
+//   sqlc v1.20.0
 // source: user_queries.sql
 
 package gendb
 
 import (
 	"context"
+	"database/sql"
 
 	"github.com/TulgaCG/add-drop-classes-api/pkg/types"
 )
@@ -17,7 +18,7 @@ INSERT INTO users (
 ) VALUES (
     ?, ?
 )
-RETURNING id, username, password, token, token_expire_at
+RETURNING id, username
 `
 
 type CreateUserParams struct {
@@ -25,57 +26,59 @@ type CreateUserParams struct {
 	Password string `db:"password" json:"password"`
 }
 
-func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
-	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.Password)
-	var i User
-	err := row.Scan(
-		&i.ID,
-		&i.Username,
-		&i.Password,
-		&i.Token,
-		&i.TokenExpireAt,
-	)
-	return i, err
+type CreateUserRow struct {
+	ID       types.UserID `db:"id" json:"id"`
+	Username string       `db:"username" json:"username"`
 }
 
-const deleteUser = `-- name: DeleteUser :execrows
-DELETE FROM users
-WHERE id = ?
-`
-
-func (q *Queries) DeleteUser(ctx context.Context, id types.UserID) (int64, error) {
-	result, err := q.db.ExecContext(ctx, deleteUser, id)
-	if err != nil {
-		return 0, err
-	}
-	return result.RowsAffected()
+func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
+	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.Password)
+	var i CreateUserRow
+	err := row.Scan(&i.ID, &i.Username)
+	return i, err
 }
 
 const getUser = `-- name: GetUser :one
-SELECT id, username, password, token, token_expire_at FROM users
+SELECT id, username FROM users
 WHERE id = ? LIMIT 1
 `
 
-func (q *Queries) GetUser(ctx context.Context, id types.UserID) (User, error) {
+type GetUserRow struct {
+	ID       types.UserID `db:"id" json:"id"`
+	Username string       `db:"username" json:"username"`
+}
+
+func (q *Queries) GetUser(ctx context.Context, id types.UserID) (GetUserRow, error) {
 	row := q.db.QueryRowContext(ctx, getUser, id)
-	var i User
-	err := row.Scan(
-		&i.ID,
-		&i.Username,
-		&i.Password,
-		&i.Token,
-		&i.TokenExpireAt,
-	)
+	var i GetUserRow
+	err := row.Scan(&i.ID, &i.Username)
 	return i, err
 }
 
 const getUserByUsername = `-- name: GetUserByUsername :one
-SELECT id, username, password, token, token_expire_at FROM users
+SELECT id, username FROM users
 WHERE username = ? LIMIT 1
 `
 
-func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
+type GetUserByUsernameRow struct {
+	ID       types.UserID `db:"id" json:"id"`
+	Username string       `db:"username" json:"username"`
+}
+
+func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
 	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
+	var i GetUserByUsernameRow
+	err := row.Scan(&i.ID, &i.Username)
+	return i, err
+}
+
+const getUserCredentialsWithUsername = `-- name: GetUserCredentialsWithUsername :one
+SELECT id, username, password, token, token_expire_at FROM users
+WHERE username = ? LIMIT 1
+`
+
+func (q *Queries) GetUserCredentialsWithUsername(ctx context.Context, username string) (User, error) {
+	row := q.db.QueryRowContext(ctx, getUserCredentialsWithUsername, username)
 	var i User
 	err := row.Scan(
 		&i.ID,
@@ -88,26 +91,25 @@ func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User,
 }
 
 const listUsers = `-- name: ListUsers :many
-SELECT id, username, password, token, token_expire_at FROM users
+SELECT id, username FROM users
 ORDER BY username
 `
 
-func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
+type ListUsersRow struct {
+	ID       types.UserID `db:"id" json:"id"`
+	Username string       `db:"username" json:"username"`
+}
+
+func (q *Queries) ListUsers(ctx context.Context) ([]ListUsersRow, error) {
 	rows, err := q.db.QueryContext(ctx, listUsers)
 	if err != nil {
 		return nil, err
 	}
 	defer rows.Close()
-	var items []User
+	var items []ListUsersRow
 	for rows.Next() {
-		var i User
-		if err := rows.Scan(
-			&i.ID,
-			&i.Username,
-			&i.Password,
-			&i.Token,
-			&i.TokenExpireAt,
-		); err != nil {
+		var i ListUsersRow
+		if err := rows.Scan(&i.ID, &i.Username); err != nil {
 			return nil, err
 		}
 		items = append(items, i)
@@ -121,12 +123,54 @@ func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
 	return items, nil
 }
 
+const updateToken = `-- name: UpdateToken :one
+UPDATE users
+set token = ?,
+    token_expire_at = ?
+WHERE id = ?
+RETURNING username, token
+`
+
+type UpdateTokenParams struct {
+	Token         sql.NullString `db:"token" json:"token"`
+	TokenExpireAt sql.NullTime   `db:"token_expire_at" json:"tokenExpireAt"`
+	ID            types.UserID   `db:"id" json:"id"`
+}
+
+type UpdateTokenRow struct {
+	Username string         `db:"username" json:"username"`
+	Token    sql.NullString `db:"token" json:"token"`
+}
+
+func (q *Queries) UpdateToken(ctx context.Context, arg UpdateTokenParams) (UpdateTokenRow, error) {
+	row := q.db.QueryRowContext(ctx, updateToken, arg.Token, arg.TokenExpireAt, arg.ID)
+	var i UpdateTokenRow
+	err := row.Scan(&i.Username, &i.Token)
+	return i, err
+}
+
+const updateTokenExpirationDate = `-- name: UpdateTokenExpirationDate :exec
+UPDATE users
+set token_expire_at = ?
+WHERE id = ?
+`
+
+type UpdateTokenExpirationDateParams struct {
+	TokenExpireAt sql.NullTime `db:"token_expire_at" json:"tokenExpireAt"`
+	ID            types.UserID `db:"id" json:"id"`
+}
+
+func (q *Queries) UpdateTokenExpirationDate(ctx context.Context, arg UpdateTokenExpirationDateParams) error {
+	_, err := q.db.ExecContext(ctx, updateTokenExpirationDate, arg.TokenExpireAt, arg.ID)
+	return err
+}
+
 const updateUser = `-- name: UpdateUser :one
 UPDATE users
 set username = ?,
 password = ?
 WHERE id = ?
-RETURNING id, username, password, token, token_expire_at
+RETURNING id, username
 `
 
 type UpdateUserParams struct {
@@ -135,15 +179,14 @@ type UpdateUserParams struct {
 	ID       types.UserID `db:"id" json:"id"`
 }
 
-func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
+type UpdateUserRow struct {
+	ID       types.UserID `db:"id" json:"id"`
+	Username string       `db:"username" json:"username"`
+}
+
+func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
 	row := q.db.QueryRowContext(ctx, updateUser, arg.Username, arg.Password, arg.ID)
-	var i User
-	err := row.Scan(
-		&i.ID,
-		&i.Username,
-		&i.Password,
-		&i.Token,
-		&i.TokenExpireAt,
-	)
+	var i UpdateUserRow
+	err := row.Scan(&i.ID, &i.Username)
 	return i, err
 }
diff --git a/pkg/gendb/user_role_queries.sql.go b/pkg/gendb/user_role_queries.sql.go
deleted file mode 100644
index 6c48d3e..0000000
--- a/pkg/gendb/user_role_queries.sql.go
+++ /dev/null
@@ -1,80 +0,0 @@
-// Code generated by sqlc. DO NOT EDIT.
-// versions:
-//   sqlc v1.19.1
-// source: user_role_queries.sql
-
-package gendb
-
-import (
-	"context"
-
-	"github.com/TulgaCG/add-drop-classes-api/pkg/types"
-)
-
-const createUserRole = `-- name: CreateUserRole :exec
-INSERT INTO user_roles (user_id, role_id)
-SELECT ?, roles.id
-FROM roles
-WHERE roles.role = ?
-`
-
-type CreateUserRoleParams struct {
-	UserID int64  `db:"user_id" json:"userId"`
-	Role   string `db:"role" json:"role"`
-}
-
-func (q *Queries) CreateUserRole(ctx context.Context, arg CreateUserRoleParams) error {
-	_, err := q.db.ExecContext(ctx, createUserRole, arg.UserID, arg.Role)
-	return err
-}
-
-const deleteUserRole = `-- name: DeleteUserRole :exec
-DELETE FROM user_roles
-WHERE user_id = ?
-AND role_id = (
-    SELECT id
-    FROM roles
-    WHERE role = ?
-)
-`
-
-type DeleteUserRoleParams struct {
-	UserID int64  `db:"user_id" json:"userId"`
-	Role   string `db:"role" json:"role"`
-}
-
-func (q *Queries) DeleteUserRole(ctx context.Context, arg DeleteUserRoleParams) error {
-	_, err := q.db.ExecContext(ctx, deleteUserRole, arg.UserID, arg.Role)
-	return err
-}
-
-const getUserRole = `-- name: GetUserRole :many
-SELECT r.role
-FROM users u
-JOIN user_roles ur ON u.id = ur.user_id
-JOIN roles r ON ur.role_id = r.id
-WHERE u.id = ?
-`
-
-func (q *Queries) GetUserRole(ctx context.Context, id types.UserID) ([]string, error) {
-	rows, err := q.db.QueryContext(ctx, getUserRole, id)
-	if err != nil {
-		return nil, err
-	}
-	defer rows.Close()
-	var items []string
-	for rows.Next() {
-		var role string
-		if err := rows.Scan(&role); err != nil {
-			return nil, err
-		}
-		items = append(items, role)
-	}
-	if err := rows.Close(); err != nil {
-		return nil, err
-	}
-	if err := rows.Err(); err != nil {
-		return nil, err
-	}
-	return items, nil
-}
diff --git a/pkg/middleware/auth.go b/pkg/middleware/auth.go
index ff1470d..904e66d 100644
--- a/pkg/middleware/auth.go
+++ b/pkg/middleware/auth.go
@@ -1,7 +1,8 @@
 package middleware
 
 import (
-	"context"
+	"fmt"
+	"log/slog"
 	"net/http"
 	"time"
 
@@ -9,32 +10,49 @@ import (
 
 	"github.com/TulgaCG/add-drop-classes-api/pkg/common"
 	"github.com/TulgaCG/add-drop-classes-api/pkg/gendb"
+	"github.com/TulgaCG/add-drop-classes-api/pkg/server/response"
 )
 
+const tokenHeaderKey = "Token"
+
 func AuthMiddleware(db *gendb.Queries) gin.HandlerFunc {
 	return func(c *gin.Context) {
+		log, ok := c.MustGet(common.LogCtxKey).(*slog.Logger)
+		if !ok {
+			c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindLoggerInCtx))
+			return
+		}
+
 		username := c.Request.Header.Get(common.UsernameHeaderKey)
-		token := c.Request.Header.Get(common.TokenHeaderKey)
+		if username == "" {
+			log.Error("no username header")
+			c.AbortWithStatusJSON(http.StatusUnauthorized, response.WithError(response.ErrFailedToAuthenticate))
+			return
+		}
+
+		token := c.Request.Header.Get(tokenHeaderKey)
+		if token == "" {
+			log.Error("no token header")
+			c.JSON(http.StatusUnauthorized, response.WithError(response.ErrFailedToAuthenticate))
+			return
+		}
 
-		user, err := db.GetUserByUsername(context.Background(), username)
+		u, err := db.GetUserCredentialsWithUsername(c, username)
 		if err != nil {
-			c.AbortWithStatusJSON(http.StatusBadRequest, common.Response{
-				Error: "login user not found",
-			})
+			log.Error("no database in gin context")
+			c.AbortWithStatusJSON(http.StatusUnauthorized, response.WithError(response.ErrFailedToAuthenticate))
 			return
 		}
 
-		if user.Token.String != token {
-			c.AbortWithStatusJSON(http.StatusNotAcceptable, common.Response{
-				Error: "login required",
-			})
+		if u.Token.String != token {
+			log.Error("failed to match user token with the header token")
+			c.AbortWithStatusJSON(http.StatusUnauthorized, response.WithError(response.ErrFailedToAuthenticate))
 			return
 		}
 
-		if time.Since(user.TokenExpireAt.Time) > 0 {
-			c.AbortWithStatusJSON(http.StatusNotAcceptable, common.Response{
-				Error: "token expired",
-			})
+		if time.Since(u.TokenExpireAt.Time) > 0 {
+			log.Error("token expired")
+			c.AbortWithStatusJSON(http.StatusUnauthorized, response.WithError(fmt.Errorf("token expired")))
 			return
 		}
 
diff --git a/pkg/middleware/log.go b/pkg/middleware/log.go
new file mode 100644
index 0000000..5043ab1
--- /dev/null
+++ b/pkg/middleware/log.go
@@ -0,0 +1,16 @@
+package middleware
+
+import (
+	"log/slog"
+
+	"github.com/gin-gonic/gin"
+
+	"github.com/TulgaCG/add-drop-classes-api/pkg/common"
+)
+
+func LogMiddleware(log *slog.Logger) gin.HandlerFunc {
+	return func(c *gin.Context) {
+		c.Set(common.LogCtxKey, log)
+		c.Next()
+	}
+}
diff --git a/pkg/server/response/response.go b/pkg/server/response/response.go
new file mode 100644
index 0000000..7dbd2e0
--- /dev/null
+++ b/pkg/server/response/response.go
@@ -0,0 +1,37 @@
+package response
+
+import "errors"
+
+var (
+	ErrFailedToAuthenticate    = errors.New("failed to authenticate, check username, password or session")
+	ErrFailedToFindDBInCtx     = errors.New("failed to find database in the context")
+	ErrFailedToFindLoggerInCtx = errors.New("failed to find logger in the context")
+	ErrInvalidParamIDFormat    = errors.New("invalid id format, id must be integer")
+	ErrInvalidRequestFormat    = errors.New("invalid request format")
+)
+
+type Response struct {
+	Data  any    `json:"data"`
+	Error string `json:"error"`
+}
+
+func New(data any, err error) Response {
+	if err == nil {
+		return Response{
+			Data: data,
+		}
+	}
+
+	return Response{
+		Data:  data,
+		Error: err.Error(),
+	}
+}
+
+func WithData(data any) Response {
+	return New(data, nil)
+}
+
+func WithError(err error) Response {
+	return New(nil, err)
+}
diff --git a/pkg/server/server.go b/pkg/server/server.go
index deba0a2..31ebc54 100644
--- a/pkg/server/server.go
+++ b/pkg/server/server.go
@@ -1,6 +1,8 @@
 package server
 
 import (
+	"log/slog"
+
 	"github.com/gin-gonic/gin"
 
 	"github.com/TulgaCG/add-drop-classes-api/pkg/auth"
@@ -9,20 +11,18 @@ import (
 	"github.com/TulgaCG/add-drop-classes-api/pkg/user"
 )
 
-func New(db *gendb.Queries) *gin.Engine {
+func New(db *gendb.Queries, log *slog.Logger) *gin.Engine {
 	r := gin.Default()
 
-	// Auth required requests
-	g1 := r.Group("/api", middleware.DBMiddleware(db), middleware.AuthMiddleware(db))
-	g1.GET("/users", user.Get)
-	g1.GET("/users/:id", user.GetByID)
-	g1.PUT("/users", user.Update)
-	g1.DELETE("/users", user.Delete)
+	g1 := r.Group("/api", middleware.LogMiddleware(log), middleware.DBMiddleware(db))
+	g1.GET("/logout", auth.LogoutHandler)
+	g1.POST("/login", auth.LoginHandler)
+	g1.POST("/users", user.CreateHandler)
 
-	g2 := r.Group("/api", middleware.DBMiddleware(db))
-	g2.GET("/logout", auth.Logout)
-	g2.POST("/login", auth.Login)
-	g2.POST("/users:id", user.Post)
+	g2 := r.Group("/api", middleware.LogMiddleware(log), middleware.DBMiddleware(db), middleware.AuthMiddleware(db))
+	g2.GET("/users", user.ListHandler)
+	g2.GET("/users/:id", user.GetHandler)
+	g2.PUT("/users", user.UpdateHandler)
 
 	return r
 }
diff --git a/pkg/user/handler.go b/pkg/user/handler.go
new file mode 100644
index 0000000..fb588f9
--- /dev/null
+++ b/pkg/user/handler.go
@@ -0,0 +1,140 @@
+package user
+
+import (
+	"log/slog"
+	"net/http"
+	"strconv"
+
+	"github.com/gin-gonic/gin"
+
+	"github.com/TulgaCG/add-drop-classes-api/pkg/common"
+	"github.com/TulgaCG/add-drop-classes-api/pkg/gendb"
+	"github.com/TulgaCG/add-drop-classes-api/pkg/server/response"
+	"github.com/TulgaCG/add-drop-classes-api/pkg/types"
+)
+
+func CreateHandler(c *gin.Context) {
+	log, ok := c.MustGet(common.LogCtxKey).(*slog.Logger)
+	if !ok {
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindLoggerInCtx))
+		return
+	}
+
+	var req CreateUserRequest
+	if err := c.BindJSON(&req); err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusBadRequest, response.WithError(response.ErrInvalidRequestFormat))
+		return
+	}
+
+	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
+	if !ok {
+		log.Error(response.ErrFailedToFindDBInCtx.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindDBInCtx))
+		return
+	}
+
+	row, err := createUser(c, db, req.Username, req.Password)
+	if err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(err))
+		return
+	}
+
+	c.JSON(http.StatusOK, response.WithData(row))
+}
+
+func ListHandler(c *gin.Context) {
+	log, ok := c.MustGet(common.LogCtxKey).(*slog.Logger)
+	if !ok {
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindLoggerInCtx))
+		return
+	}
+
+	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
+	if !ok {
+		log.Error(response.ErrFailedToFindDBInCtx.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindDBInCtx))
+		return
+	}
+
+	rows, err := listUsers(c, db)
+	if err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(err))
+	}
+
+	c.JSON(http.StatusOK, response.WithData(rows))
+}
+
+func GetHandler(c *gin.Context) {
+	log, ok := c.MustGet(common.LogCtxKey).(*slog.Logger)
+	if !ok {
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindLoggerInCtx))
+		return
+	}
+
+	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
+	if !ok {
+		log.Error(response.ErrFailedToFindDBInCtx.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindDBInCtx))
+		return
+	}
+
+	id, err := strconv.Atoi(c.Param("id"))
+	if err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusBadRequest, response.WithError(response.ErrInvalidParamIDFormat))
+		return
+	}
+
+	row, err := getUser(c, db, types.UserID(id))
+	if err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(err))
+	}
+
+	c.JSON(http.StatusOK, response.WithData(row))
+}
+
+func UpdateHandler(c *gin.Context) {
+	log, ok := c.MustGet(common.LogCtxKey).(*slog.Logger)
+	if !ok {
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindLoggerInCtx))
+		return
+	}
+
+	var req UpdateUserRequest
+	if err := c.BindJSON(&req); err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusBadRequest, response.WithError(response.ErrInvalidRequestFormat))
+		return
+	}
+
+	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
+	if !ok {
+		log.Error(response.ErrFailedToFindDBInCtx.Error())
+		c.JSON(http.StatusInternalServerError, response.WithError(response.ErrFailedToFindDBInCtx))
+		return
+	}
+
+	u, err := getUserByUsername(c, db, req.Username)
+	if err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusBadRequest, response.WithError(err))
+		return
+	}
+
+	row, err := updateUser(c, db, gendb.UpdateUserParams{
+		ID:       u.ID,
+		Username: req.NewUsername,
+		Password: req.NewPassword,
+	})
+	if err != nil {
+		log.Error(err.Error())
+		c.JSON(http.StatusBadRequest, response.WithError(err))
+		return
+	}
+
+	c.JSON(http.StatusOK, response.WithData(row))
+}
diff --git a/pkg/user/request.go b/pkg/user/request.go
new file mode 100644
index 0000000..8944072
--- /dev/null
+++ b/pkg/user/request.go
@@ -0,0 +1,14 @@
+package user
+
+// TODO: Add playground-go/validator tags
+
+type CreateUserRequest struct {
+	Username string `json:"username"`
+	Password string `json:"password"`
+}
+
+type UpdateUserRequest struct {
+	Username    string `json:"username"`
+	NewUsername string `json:"newUsername"`
+	NewPassword string `json:"newPassword"`
+}
diff --git a/pkg/user/user.go b/pkg/user/user.go
index 25baf3a..34a84fc 100644
--- a/pkg/user/user.go
+++ b/pkg/user/user.go
@@ -2,161 +2,63 @@ package user
 
 import (
 	"context"
-	"net/http"
-	"strconv"
+	"fmt"
 
-	"github.com/gin-gonic/gin"
+	"golang.org/x/crypto/bcrypt"
 
-	"github.com/TulgaCG/add-drop-classes-api/pkg/common"
 	"github.com/TulgaCG/add-drop-classes-api/pkg/gendb"
 	"github.com/TulgaCG/add-drop-classes-api/pkg/types"
 )
 
-func Post(c *gin.Context) {
-	var req gendb.CreateUserParams
-	err := c.Bind(&req)
+func createUser(ctx context.Context, db *gendb.Queries, username, password string) (gendb.CreateUserRow, error) {
+	hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
 	if err != nil {
-		c.JSON(http.StatusBadRequest, common.Response{
-			Error: "bad request",
-		})
-		return
+		return gendb.CreateUserRow{}, fmt.Errorf("failed to generate hashed password: %w", err)
 	}
 
-	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
-	if !ok {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to get db",
-		})
-		return
-	}
-
-	newUser, err := db.CreateUser(context.Background(), req)
-	if err != nil {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to create user",
-		})
-		return
-	}
-
-	c.JSON(http.StatusOK, common.Response{
-		Data: newUser,
+	row, err := db.CreateUser(ctx, gendb.CreateUserParams{
+		Username: username,
+		Password: string(hashedPassword),
 	})
-}
-
-func Get(c *gin.Context) {
-	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
-	if !ok {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to get db",
-		})
-		return
-	}
-
-	users, err := db.ListUsers(context.Background())
 	if err != nil {
-		c.JSON(http.StatusNoContent, common.Response{
-			Error: "failed to list users",
-		})
-		return
+		return gendb.CreateUserRow{}, fmt.Errorf("failed to create user: %w", err)
 	}
 
-	c.JSON(http.StatusOK, gin.H{
-		"users": users,
-	})
+	return row, nil
 }
 
-func GetByID(c *gin.Context) {
-	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
-	if !ok {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to get db",
-		})
-		return
-	}
-
-	id, err := strconv.Atoi(c.Param("id"))
+func listUsers(ctx context.Context, db *gendb.Queries) ([]gendb.ListUsersRow, error) {
+	rows, err := db.ListUsers(ctx)
 	if err != nil {
-		c.JSON(http.StatusBadRequest, common.Response{
-			Error: "id must be integer",
-		})
-		return
+		return nil, fmt.Errorf("failed to list users: %w", err)
 	}
 
-	u, err := db.GetUser(context.Background(), types.UserID(id))
-	if err != nil {
-		c.JSON(http.StatusNoContent, common.Response{
-			Error: "failed to get user by id",
-		})
-		return
-	}
-
-	c.JSON(http.StatusOK, u)
+	return rows, nil
 }
 
-func Update(c *gin.Context) {
-	var req gendb.UpdateUserParams
-	err := c.Bind(&req)
+func getUser(ctx context.Context, db *gendb.Queries, id types.UserID) (gendb.GetUserRow, error) {
+	row, err := db.GetUser(ctx, id)
 	if err != nil {
-		c.JSON(http.StatusBadRequest, common.Response{
-			Error: "bad request",
-		})
-		return
+		return gendb.GetUserRow{}, fmt.Errorf("failed to get user: %w", err)
 	}
 
-	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
-	if !ok {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to get db",
-		})
-		return
-	}
+	return row, nil
+}
 
-	u, err := db.UpdateUser(context.Background(), gendb.UpdateUserParams{
-		Username: req.Username,
-		Password: req.Password,
-		ID:       req.ID,
-	})
+func getUserByUsername(ctx context.Context, db *gendb.Queries, username string) (gendb.GetUserByUsernameRow, error) {
+	row, err := db.GetUserByUsername(ctx, username)
 	if err != nil {
-		c.JSON(http.StatusBadRequest, common.Response{
-			Error: "failed to update user",
-		})
-		return
+		return gendb.GetUserByUsernameRow{}, fmt.Errorf("failed to get user by username: %w", err)
 	}
 
-	c.JSON(http.StatusOK, u)
+	return row, nil
 }
 
-func Delete(c *gin.Context) {
-	db, ok := c.MustGet(common.DatabaseCtxKey).(*gendb.Queries)
-	if !ok {
-		c.JSON(http.StatusInternalServerError, common.Response{
-			Error: "failed to get db",
-		})
-		return
-	}
-
-	id, err := strconv.Atoi(c.Param("id"))
-	if err != nil {
-		c.JSON(http.StatusBadRequest, common.Response{
-			Error: "failed to get id",
-		})
-		return
-	}
-
-	rows, err := db.DeleteUser(context.Background(), types.UserID(id))
+func updateUser(ctx context.Context, db *gendb.Queries, params gendb.UpdateUserParams) (gendb.UpdateUserRow, error) {
+	u, err := db.UpdateUser(ctx, params)
 	if err != nil {
-		c.JSON(http.StatusNoContent, common.Response{
-			Error: "failed to delete user",
-		})
-		return
-	}
-
-	if rows <= 0 {
-		c.JSON(http.StatusBadRequest, common.Response{
-			Error: "user to delete not found",
-		})
-		return
+		return gendb.UpdateUserRow{}, fmt.Errorf("failed to update the user: %w", err)
 	}
 
-	c.JSON(http.StatusOK, common.Response{})
+	return u, nil
 }
diff --git a/sqlc.yaml b/sqlc.yaml
index 960d4de..fa3f0c6 100644
--- a/sqlc.yaml
+++ b/sqlc.yaml
@@ -13,6 +13,12 @@ sql:
         overrides:
           - column: users.id
             go_type: github.com/TulgaCG/add-drop-classes-api/pkg/types.UserID
-          
+
+          - column: "*.user_id"
+            go_type: github.com/TulgaCG/add-drop-classes-api/pkg/types.UserID
+
           - column: lectures.id
-            go_type: github.com/TulgaCG/add-drop-classes-api/pkg/types.LectureID
\ No newline at end of file
+            go_type: github.com/TulgaCG/add-drop-classes-api/pkg/types.LectureID
+
+          - column: "*.lecture_id"
+            go_type: github.com/TulgaCG/add-drop-classes-api/pkg/types.LectureID
